
import fs from 'fs-extra';
import path from 'path';
import z from 'zod';
import { GeneratorOptions } from "@prisma/generator-helper";
import { writeFileTypescript } from '../utils/writeFileTypescript'
import { getRelativePathFromOutput, getAbsolutePath } from '../utils/getRelativePathFromOutput';
import { toCapitlize, toUncapitlize } from '../utils/string'

export const generatorConfigType = z.object({
  prismaClientPath: z.string({ required_error: 'prismaClientPath is required' }),
  contextTypePath: z.string({ required_error: 'contextTypePath is required' }),
  rulesfolderPath: z.string({ required_error: 'rulesfolderPath is required' }),

  trpcProcedurePath: z.string().optional(),
})

export const getPaths = (options: GeneratorOptions) => {
  const generatorConfig = generatorConfigType.parse(options.generator.config);

  return {
    relativeClientPathToOutput: getRelativePathFromOutput(options, generatorConfig.prismaClientPath),
    relativeContextPathToOutput: getRelativePathFromOutput(options, generatorConfig.contextTypePath),
    relativeRulesfolderPath: getRelativePathFromOutput(options, generatorConfig.rulesfolderPath),
    relativeTrpcProcedurePath: getRelativePathFromOutput(options, generatorConfig.trpcProcedurePath),

    absoluteRulesFolderPath: getAbsolutePath(options, generatorConfig.rulesfolderPath),

    schemaFolderPath: path.resolve(options.generator.output?.value, 'schema'),
    outputFolderPath: path.resolve(options.generator.output?.value),
  };
}

export const generateGuardedPrisma = async (options: GeneratorOptions) => {
  const {
    relativeClientPathToOutput,
    relativeContextPathToOutput,
    outputFolderPath,
    relativeTrpcProcedurePath
  } = getPaths(options);

  const generated = `
    // ---------------------------------------------- //
    // This file is generated by prisma-security-rules //
    // ---------------------------------------------- //
    
    import z from 'zod';
    import { withSecurityRules } from 'prisma-security-rules'
    import { prisma } from '${relativeClientPathToOutput}'
    import { Context } from '${relativeContextPathToOutput}'
    import * as rules from '../../rules'
    import * as Schema from './schema';

    export * as Schema from './schema';

    ${'export type ModelName = Capitalize<Exclude<keyof typeof prisma, `$${ string }` | symbol | number>>;'}
    ${'export type WhereRule<Name extends ModelName> = (ctx: Context, arg: z.infer<typeof Schema[`${ Name }WhereInputSchema`]>) => z.infer<typeof Schema[`${ Name }WhereInputSchema`]>'}
    ${'export type WriteRule<Name extends ModelName> = (ctx: Context, arg: z.infer<typeof Schema[`${ Name }CreateArgsSchema`]>[\'data\']) => z.infer<typeof Schema[`${ Name }CreateArgsSchema`]>[\'data\']'}

    export const secureClient = (ctx: Context) => {
      return withSecurityRules(prisma, rules, ctx)
    }
  `;

  await fs.ensureDir(outputFolderPath);
  const outputIndexPath = path.resolve(outputFolderPath, 'index.ts');
  await writeFileTypescript(outputIndexPath, generated);
}

export const generateTrpcRouter = async (options: GeneratorOptions) => {
  const { relativeTrpcProcedurePath } = getPaths(options);

  return `
    import { trpc, procedure } from '${relativeTrpcProcedurePath}'

    export const router = trpc.router({
      ${options.dmmf.datamodel.models.map(model => {
    const actions = ['findMany', 'findUnique'];
    return `
          ${toUncapitlize(model.name)}: trpc.router({
          
            ${actions.map(action => `
              ${action}: procedure
                .input(Schema.${model.name}${toCapitlize(action)}ArgsSchema)
                .query(({ ctx, input }) => withSecurityRules(prisma, rules, ctx).${toUncapitlize(model.name)}.${action}(input)),
            `).join('')}
        }),
        `;
  }).join('\n')}
    });
  `;
}